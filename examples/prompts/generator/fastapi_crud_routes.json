{
  "name": "Generador de Rutas CRUD para FastAPI",
  "description": "Genera un módulo completo de rutas CRUD para un modelo FastAPI con autenticación, validación y manejo de errores.",
  "system_prompt": "Eres un experto desarrollador de APIs REST con FastAPI. Genera código limpio, seguro y bien documentado que siga las mejores prácticas de desarrollo de APIs. Incluye manejo de errores, validación de datos, autenticación, paginación y documentación con OpenAPI.",
  "parameters": {
    "model_name": "string: Nombre del modelo en singular (ej: 'User', 'Product')",
    "model_description": "string: Descripción del propósito del modelo",
    "route_prefix": "string: Prefijo para las rutas (ej: '/products')
  },
  "example_input": {
    "model_name": "Product",
    "model_description": "Representa un producto en el catálogo de la tienda",
    "route_prefix": "/products"
  },
  "example_output": {
    "file_path": "api/v1/endpoints/products.py",
    "content": """\n""\"\nMódulo de rutas para la gestión de productos.\n\nEste módulo proporciona endpoints para realizar operaciones CRUD en productos,\nincluyendo creación, lectura, actualización y eliminación, con soporte para\nbúsqueda, filtrado y paginación.\n"""\n\nfrom typing import Any, Dict, List, Optional\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\nfrom app.core.config import settings\nfrom app.utils import send_new_product_notification\n\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\n@router.post(\"/\", response_model=schemas.Product, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    *,\n    db: Session = Depends(deps.get_db),\n    product_in: schemas.ProductCreate,\n    current_user: models.User = Depends(deps.get_current_active_superuser),  # type: ignore\n) -> Any:\n    \"\"\"\n    Crear un nuevo producto.\n    \n    Solo usuarios administradores pueden crear productos.\n    \n    - **name**: Nombre del producto (requerido, máximo 100 caracteres)\n    - **description**: Descripción detallada (opcional)\n    - **price**: Precio (debe ser mayor a 0)\n    - **stock_quantity**: Cantidad en inventario (mínimo 0)\n    - **category_id**: ID de la categoría (opcional)\n    \"\"\"\n    # Verificar si ya existe un producto con el mismo nombre\n    product = crud.product.get_by_name(db, name=product_in.name)\n    if product:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Ya existe un producto con este nombre.\",\n        )\n    \n    # Crear el producto\n    product = crud.product.create(db, obj_in=product_in)\n    \n    # Notificar al equipo sobre el nuevo producto (asíncrono)\n    if settings.EMAILS_ENABLED and product_in.stock_quantity > 0:\n        send_new_product_notification(product=product)\n    \n    return product\n\n\n@router.get(\"/\", response_model=schemas.ProductList)\nasync def read_products(\n    db: Session = Depends(deps.get_db),\n    skip: int = 0,\n    limit: int = Query(\n        default=100, \n        le=1000, \n        description=\"Número máximo de resultados por página (máx. 1000)\"\n    ),\n    q: Optional[str] = Query(\n        None, \n        min_length=2, \n        max_length=100,\n        description=\"Término de búsqueda para filtrar productos por nombre o descripción\"\n    ),\n    min_price: Optional[float] = Query(\n        None, \n        gt=0, \n        description=\"Filtrar por precio mínimo\"\n    ),\n    max_price: Optional[float] = Query(\n        None, \n        gt=0, \n        description=\"Filtrar por precio máximo\"\n    ),\n    category_id: Optional[int] = Query(\n        None, \n        description=\"Filtrar por ID de categoría\"\n    ),\n    in_stock: Optional[bool] = Query(\n        None, \n        description=\"Filtrar solo productos con stock disponible\"\n    ),\n) -> Any:\n    \"\"\"\n    Obtener una lista paginada de productos.\n    \n    Los productos se pueden filtrar por término de búsqueda, rango de precios,\n    categoría y disponibilidad.\n    \"\"\"\n    # Validar que min_price no sea mayor que max_price\n    if min_price is not None and max_price is not None and min_price > max_price:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"El precio mínimo no puede ser mayor que el precio máximo\",\n        )\n    \n    # Construir filtros\n    filters: Dict[str, Any] = {\n        \"q\": q,\n        \"min_price\": min_price,\n        \"max_price\": max_price,\n        \"category_id\": category_id,\n        \"in_stock\": in_stock,\n    }\n    \n    # Obtener productos con filtros\n    products = crud.product.get_multi(\n        db, \n        skip=skip, \n        limit=limit, \n        filters=filters\n    )\n    \n    # Contar el total de productos (para paginación)\n    total = crud.product.count(db, filters=filters)\n    \n    # Construir respuesta\n    return {\n        \"items\": products.all(),\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit,\n    }\n\n\n@router.get(\"/{product_id}\", response_model=schemas.Product)\nasync def read_product(\n    product_id: int,\n    db: Session = Depends(deps.get_db),\n) -> Any:\n    \"\"\"\n    Obtener un producto por su ID.\n    \n    - **product_id**: ID del producto a recuperar\n    \"\"\"\n    product = crud.product.get(db, id=product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Producto no encontrado\",\n        )\n    return product\n\n\n@router.put(\"/{product_id}\", response_model=schemas.Product)\nasync def update_product(\n    *,\n    db: Session = Depends(deps.get_db),\n    product_id: int,\n    product_in: schemas.ProductUpdate,\n    current_user: models.User = Depends(deps.get_current_active_superuser),  # type: ignore\n) -> Any:\n    \"\"\"\n    Actualizar un producto existente.\n    \n    Solo usuarios administradores pueden actualizar productos.\n    \n    - **product_id**: ID del producto a actualizar\n    - **name**: Nuevo nombre (opcional)\n    - **description**: Nueva descripción (opcional)\n    - **price**: Nuevo precio (opcional)\n    - **stock_quantity**: Nueva cantidad en inventario (opcional)\n    - **is_active**: Estado de activación (opcional)\n    \"\"\"\n    # Verificar si el producto existe\n    product = crud.product.get(db, id=product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Producto no encontrado\",\n        )\n    \n    # Verificar si ya existe otro producto con el mismo nombre\n    if product_in.name and product_in.name != product.name:\n        existing_product = crud.product.get_by_name(db, name=product_in.name)\n        if existing_product and existing_product.id != product_id:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Ya existe otro producto con este nombre\",\n            )\n    \n    # Actualizar el producto\n    product = crud.product.update(db, db_obj=product, obj_in=product_in)\n    return product\n\n\n@router.delete(\"/{product_id}\", response_model=schemas.Product)\nasync def delete_product(\n    *,\n    db: Session = Depends(deps.get_db),\n    product_id: int,\n    current_user: models.User = Depends(deps.get_current_active_superuser),  # type: ignore\n) -> Any:\n    \"\"\"\n    Eliminar un producto.\n    \n    Solo usuarios administradores pueden eliminar productos.\n    \n    - **product_id**: ID del producto a eliminar\n    \"\"\"\n    # Verificar si el producto existe\n    product = crud.product.get(db, id=product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Producto no encontrado\",\n        )\n    \n    # Verificar si hay pedidos asociados al producto\n    if product.order_items:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"No se puede eliminar un producto con pedidos asociados\",\n        )\n    \n    # Eliminar el producto\n    product = crud.product.remove(db, id=product_id)\n    return product\n\n\n@router.post(\"/{product_id}/images/\", response_model=schemas.ProductImage)\nasync def upload_product_image(\n    *,\n    db: Session = Depends(deps.get_db),\n    product_id: int,\n    file: UploadFile = File(..., description=\"Archivo de imagen a subir\"),\n    current_user: models.User = Depends(deps.get_current_active_superuser),  # type: ignore\n) -> Any:\n    \"\"\"\n    Subir una imagen para un producto.\n    \n    Solo usuarios administradores pueden subir imágenes.\n    \n    - **product_id**: ID del producto\n    - **file**: Archivo de imagen (JPEG, PNG, máximo 5MB)\n    \"\"\"\n    # Verificar si el producto existe\n    product = crud.product.get(db, id=product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Producto no encontrado\",\n        )\n    \n    # Validar el tipo de archivo\n    content_type = file.content_type\n    if content_type not in [\"image/jpeg\", \"image/png\"]:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Solo se permiten archivos de imagen (JPEG, PNG)\",\n        )\n    \n    # Validar el tamaño del archivo (máx. 5MB)\n    max_size = 5 * 1024 * 1024  # 5MB\n    file.file.seek(0, 2)  # Ir al final del archivo\n    file_size = file.file.tell()\n    file.file.seek(0)  # Volver al inicio del archivo\n    \n    if file_size > max_size:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"El archivo es demasiado grande. Tamaño máximo permitido: {max_size/1024/1024}MB\",\n        )\n    \n    # Subir la imagen al almacenamiento (ejemplo con AWS S3)\n    try:\n        # Aquí iría la lógica para subir el archivo a S3 o almacenamiento local\n        # Por simplicidad, simulamos la subida\n        image_url = f\"https://storage.example.com/products/{product_id}/{file.filename}\"\n        \n        # Crear el registro de la imagen en la base de datos\n        image_in = schemas.ProductImageCreate(\n            url=image_url,\n            alt_text=f\"Imagen de {product.name}\",\n            is_primary=not bool(product.images),  # Primera imagen como principal\n        )\n        \n        image = crud.product_image.create_with_product(\n            db, \n            obj_in=image_in, \n            product_id=product_id\n        )\n        \n        return image\n        \n    except Exception as e:\n        logger.error(f\"Error al subir la imagen: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Error al procesar la imagen\",\n        )\n\n\n@router.post(\"/{product_id}/reviews/\", response_model=schemas.Review)\nasync def create_product_review(\n    *,\n    db: Session = Depends(deps.get_db),\n    product_id: int,\n    review_in: schemas.ReviewCreate,\n    current_user: models.User = Depends(deps.get_current_active_user),  # type: ignore\n) -> Any:\n    \"\"\"\n    Crear una reseña para un producto.\n    \n    - **product_id**: ID del producto a reseñar\n    - **rating**: Calificación (1-5 estrellas)\n    - **comment**: Comentario de la reseña (opcional)\n    \"\"\"\n    # Verificar si el producto existe\n    product = crud.product.get(db, id=product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Producto no encontrado\",\n        )\n    \n    # Verificar si el usuario ya ha reseñado este producto\n    existing_review = (\n        db.query(models.Review)\n        .filter(\n            models.Review.product_id == product_id,\n            models.Review.user_id == current_user.id,\n        )\n        .first()\n    )\n    \n    if existing_review:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Ya has realizado una reseña para este producto\",\n        )\n    \n    # Crear la reseña\n    review = crud.review.create_with_product_and_user(\n        db, \n        obj_in=review_in, \n        product_id=product_id, \n        user_id=current_user.id\n    )\n    \n    # Actualizar el promedio de calificaciones del producto\n    crud.product.update_rating_average(db, product=product)\n    \n    return review\n""",
    "language": "python",
    "dependencies": [
      "fastapi",
      "sqlalchemy",
      "pydantic",
      "python-multipart"
    ],
    "documentation": "Este módulo implementa los endpoints para la gestión de productos, incluyendo operaciones CRUD, subida de imágenes y reseñas. Incluye autenticación, autorización, validación de datos, manejo de errores y documentación OpenAPI."
  }
}
