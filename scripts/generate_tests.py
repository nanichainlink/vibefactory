"""
Test Generation Script for Vibe Coding Workflow

This script automatically generates test cases for Python modules using AI assistance.
It analyzes the target module and creates appropriate test cases based on function signatures,
docstrings, and type hints.
"""

import ast
import inspect
import importlib
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("test_generation.log"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)


class TestGenerator:
    """Generates test cases for Python modules and functions."""

    def __init__(self, target_path: str, output_dir: str = "tests"):
        """Initialize the TestGenerator.
        
        Args:
            target_path: Path to the Python module or package to generate tests for
            output_dir: Directory to save generated test files (default: 'tests')
        """
        self.target_path = Path(target_path).resolve()
        self.output_dir = Path(output_dir).resolve()
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Dictionary to store information about the target module
        self.module_info: Dict = {}
        
        # Configure test file template
        self.test_file_template = """""""
# Generated by Vibe Coding Test Generator
# Date: {generation_date}
# Target: {target_module}

""""Test cases for {target_module}"""

import pytest
import sys
import os

# Add the parent directory to the Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the module to test
{imports}

{test_cases}
""""""

    def generate_tests(self) -> None:
        """Generate test cases for the target module."""
        logger.info(f"Generating tests for: {self.target_path}")
        
        # Check if the target is a file or directory
        if self.target_path.is_file():
            self._process_file(self.target_path)
        elif self.target_path.is_dir():
            self._process_directory(self.target_path)
        else:
            logger.error(f"Target path does not exist: {self.target_path}")
            return
        
        logger.info("Test generation complete")
    
    def _process_directory(self, directory: Path) -> None:
        """Process all Python files in a directory.
        
        Args:
            directory: Directory containing Python files to process
        """
        logger.info(f"Processing directory: {directory}")
        
        for file_path in directory.glob("**/*.py"):
            # Skip __init__.py and test files
            if file_path.name == "__init__.py" or file_path.name.startswith("test_"):
                continue
            self._process_file(file_path)
    
    def _process_file(self, file_path: Path) -> None:
        """Process a single Python file and generate tests for it.
        
        Args:
            file_path: Path to the Python file to process
        """
        logger.info(f"Processing file: {file_path}")
        
        # Parse the file to extract function and class information
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        
        try:
            tree = ast.parse(content)
        except SyntaxError as e:
            logger.error(f"Error parsing {file_path}: {e}")
            return
        
        # Extract module information
        module_name = file_path.stem
        self.module_info[module_name] = {
            "path": file_path,
            "import_path": self._get_import_path(file_path),
            "functions": [],
            "classes": [],
        }
        
        # Analyze the AST to find functions and classes
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                self._process_function(node, module_name)
            elif isinstance(node, ast.ClassDef):
                self._process_class(node, module_name)
        
        # Generate test file
        self._generate_test_file(module_name)
    
    def _process_function(self, node: ast.FunctionDef, module_name: str) -> None:
        """Process a function definition and extract relevant information.
        
        Args:
            node: The AST node for the function definition
            module_name: Name of the module containing the function
        """
        # Skip private and dunder methods
        if node.name.startswith("_") and not node.name.startswith("__"):
            return
        
        # Extract function information
        func_info = {
            "name": node.name,
            "args": [arg.arg for arg in node.args.args],
            "returns": "Any",  # Default return type
            "docstring": ast.get_docstring(node) or "",
        }
        
        # Try to get return type annotation
        if node.returns:
            if isinstance(node.returns, ast.Name):
                func_info["returns"] = node.returns.id
            elif isinstance(node.returns, ast.Constant):
                func_info["returns"] = str(node.returns.value)
        
        # Add to module info
        self.module_info[module_name]["functions"].append(func_info)
    
    def _process_class(self, node: ast.ClassDef, module_name: str) -> None:
        """Process a class definition and extract relevant information.
        
        Args:
            node: The AST node for the class definition
            module_name: Name of the module containing the class
        """
        # Skip private classes
        if node.name.startswith("_"):
            return
        
        class_info = {
            "name": node.name,
            "methods": [],
            "docstring": ast.get_docstring(node) or "",
        }
        
        # Process methods
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                # Skip private methods
                if item.name.startswith("_") and not item.name.startswith("__"):
                    continue
                
                method_info = {
                    "name": item.name,
                    "args": [arg.arg for arg in item.args.args],
                    "returns": "Any",
                    "docstring": ast.get_docstring(item) or "",
                }
                
                # Get return type annotation if available
                if item.returns:
                    if isinstance(item.returns, ast.Name):
                        method_info["returns"] = item.returns.id
                    elif isinstance(item.returns, ast.Constant):
                        method_info["returns"] = str(item.returns.value)
                
                class_info["methods"].append(method_info)
        
        # Add to module info
        self.module_info[module_name]["classes"].append(class_info)
    
    def _generate_test_file(self, module_name: str) -> None:
        """Generate a test file for the specified module.
        
        Args:
            module_name: Name of the module to generate tests for
        """
        if module_name not in self.module_info:
            logger.warning(f"No module info found for {module_name}")
            return
        
        module_info = self.module_info[module_name]
        test_cases = []
        imports = [f"import {module_name}"]
        
        # Generate test cases for functions
        for func in module_info["functions"]:
            test_case = self._generate_function_test_case(module_name, func)
            if test_case:
                test_cases.append(test_case)
        
        # Generate test cases for class methods
        for cls in module_info["classes"]:
            class_test_cases = self._generate_class_test_cases(module_name, cls)
            test_cases.extend(class_test_cases)
            
            # Add class to imports
            imports.append(f"from {module_info['import_path']} import {cls['name']}")
        
        # If no test cases were generated, skip creating the file
        if not test_cases:
            logger.info(f"No testable functions/classes found in {module_name}")
            return
        
        # Create the test file content
        test_file_content = self.test_file_template.format(
            generation_date=self._get_current_date(),
            target_module=module_name,
            imports="\n".join(sorted(set(imports))),
            test_cases="\n\n".join(test_cases),
        )
        
        # Write the test file
        test_file_path = self.output_dir / f"test_{module_name}.py"
        with open(test_file_path, "w", encoding="utf-8") as f:
            f.write(test_file_content)
        
        logger.info(f"Generated test file: {test_file_path}")
    
    def _generate_function_test_case(self, module_name: str, func_info: Dict) -> str:
        """Generate a test case for a function.
        
        Args:
            module_name: Name of the module containing the function
            func_info: Dictionary containing function information
            
        Returns:
            String containing the test case code
        """
        # Skip functions without docstrings (likely internal/private)
        if not func_info["docstring"]:
            return ""
        
        # Generate test function name
        test_func_name = f"test_{func_info['name']}"
        
        # Generate test case
        test_case = f"def {test_func_name}():\
    \"\"\"Test for {func_info['name']} function.\"\"\"
    
    # TODO: Add test implementation
    # Example:
    # result = {module_name}.{func_info['name']}(...)
    # assert result == expected_value
    
    # For now, just pass
    assert True
"
        return test_case
    
    def _generate_class_test_cases(self, module_name: str, class_info: Dict) -> List[str]:
        """Generate test cases for a class and its methods.
        
        Args:
            module_name: Name of the module containing the class
            class_info: Dictionary containing class information
            
        Returns:
            List of test case strings
        """
        test_cases = []
        
        # Skip classes without docstrings (likely internal/private)
        if not class_info["docstring"] and not any(m["docstring"] for m in class_info["methods"]):
            return []
        
        # Generate test class
        test_class_name = f"Test{class_info['name']}"
        test_class = f"class {test_class_name}:\
    \"\"\"Test cases for {class_info['name']} class.\"\"\"
    
    # TODO: Add setup/teardown methods if needed
    # def setup_method(self):
    #     self.instance = {class_info['name']}(...)
    # 
    # def teardown_method(self):
    #     pass
"
        
        # Generate test methods
        test_methods = []
        for method in class_info["methods"]:
            # Skip methods without docstrings (likely internal/private)
            if not method["docstring"]:
                continue
                
            test_method_name = f"test_{method['name']}"
            test_method = f"    def {test_method_name}(self):\
        \"\"\"Test for {method['name']} method.\"\"\"
        
        # TODO: Add test implementation
        # Example:
        # result = self.instance.{method['name']}(...)
        # assert result == expected_value
        
        # For now, just pass
        assert True
"
            test_methods.append(test_method)
        
        # If no testable methods, don't generate the test class
        if not test_methods:
            return []
        
        # Combine test class and methods
        test_class += "\n".join(test_methods)
        test_cases.append(test_class)
        
        return test_cases
    
    def _get_import_path(self, file_path: Path) -> str:
        """Get the import path for a Python file.
        
        Args:
            file_path: Path to the Python file
            
        Returns:
            Import path as a string (e.g., 'package.module')
        """
        # Get the relative path from the project root
        rel_path = file_path.relative_to(Path.cwd())
        
        # Remove the file extension and convert path to module notation
        module_path = str(rel_path.with_suffix("")).replace(os.path.sep, ".")
        
        return module_path
    
    @staticmethod
    def _get_current_date() -> str:
        """Get the current date in ISO format."""
        from datetime import datetime
        return datetime.now().isoformat()


def main():
    """Main entry point for the test generation script."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate test cases for Python modules.")
    parser.add_argument(
        "target",
        help="Path to the Python module or package to generate tests for"
    )
    parser.add_argument(
        "-o", "--output-dir",
        default="tests",
        help="Directory to save generated test files (default: 'tests')"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Generate tests
    generator = TestGenerator(args.target, args.output_dir)
    generator.generate_tests()


if __name__ == "__main__":
    main()
